#include "pch.h"
#include "tasks.h"

// note that usvfs is the only project that has to be built for both 32- and
// 64-bit architectures
//
// prebuilts are typically only used when building on appveyor, so they reuse
// whatever was last built with contiguous integration
//
// the files generated by CI are called "artifacts", they can be seen on
// https://ci.appveyor.com/project/ModOrganizer2/usvfs, by clicking on a
// platform at the bottom, then the "Artifacts" tab

namespace mob::tasks {

    usvfs::usvfs() : basic_task("usvfs") {}

    std::string usvfs::version()
    {
        return conf().version().get("usvfs");
    }

    bool usvfs::prebuilt()
    {
        return conf().prebuilt().get<bool>("usvfs");
    }

    fs::path usvfs::source_path()
    {
        return conf().path().build() / "usvfs";
    }

    void usvfs::do_clean(clean c)
    {
        if (prebuilt()) {
            if (is_set(c, clean::redownload)) {
                // the `downloader` class knows how to delete its own files, so
                // create the same downloaders and ask them to clean

                const auto x86_dls =
                    create_appveyor_downloaders(arch::x86, downloader::clean);

                const auto x64_dls =
                    create_appveyor_downloaders(arch::x64, downloader::clean);

                for (auto dl : x86_dls)
                    run_tool(*dl);

                for (auto dl : x64_dls)
                    run_tool(*dl);
            }
        }
        else {
            // delete the whole directory
            if (is_set(c, clean::reclone)) {
                git_wrap::delete_directory(cx(), source_path());

                // nothing more to do
                return;
            }

            if (is_set(c, clean::rebuild)) {
                // msbuild clean
                run_tool(create_msbuild_tool(arch::x86, msbuild::clean));
                run_tool(create_msbuild_tool(arch::x64, msbuild::clean));
            }
        }
    }

    void usvfs::do_fetch()
    {
        if (prebuilt())
            fetch_prebuilt();
        else
            fetch_from_source();
    }

    void usvfs::do_build_and_install()
    {
        if (prebuilt())
            build_and_install_prebuilt();
        else
            build_and_install_from_source();
    }

    void usvfs::fetch_prebuilt()
    {
        fetch_from_source();
        download_from_appveyor(arch::x64);
        download_from_appveyor(arch::x86);
    }

    void usvfs::build_and_install_prebuilt()
    {
        copy_prebuilt(arch::x86);
        copy_prebuilt(arch::x64);
    }

    void usvfs::fetch_from_source()
    {
        run_tool(make_git()
                     .url(make_git_url(task_conf().mo_org(), "usvfs"))
                     .branch(version())
                     .root(source_path()));
    }

    void usvfs::build_and_install_from_source()
    {
        run_tool(create_msbuild_tool(arch::x86));
        run_tool(create_msbuild_tool(arch::x64));
    }

    void usvfs::download_from_appveyor(arch a)
    {
        // create all downloaders, run them in parallel

        parallel_functions v;

        for (auto dl : create_appveyor_downloaders(a))
            v.emplace_back("usvfs", [this, dl] {
                run_tool(*dl);
            });

        parallel(v);
    }

    void usvfs::copy_prebuilt(arch a)
    {
        const auto path = conf().path();
        const auto src  = path.build() / prebuilt_directory_name(a);

        // dlls and exes to install/bin/
        op::copy_glob_to_dir_if_better(cx(), src / "*.dll", path.install_bin(),
                                       op::copy_files);

        op::copy_glob_to_dir_if_better(cx(), src / "*.exe", path.install_bin(),
                                       op::copy_files);

        // pdbs
        op::copy_glob_to_dir_if_better(cx(), src / "*.pdb", path.install_pdbs(),
                                       op::copy_files);

        // libs
        op::copy_glob_to_dir_if_better(cx(), src / "*.lib", path.install_libs(),
                                       op::copy_files);
    }

    msbuild usvfs::create_msbuild_tool(arch a, msbuild::ops o) const
    {
        // usvfs doesn't use "Win32" for 32-bit, it uses "x86"
        //
        // note that usvfs_proxy has a custom build step in Release that runs
        // usvfs/vsbuild/stage_helper.cmd, which copies everything into
        // install/

        const std::string plat = (a == arch::x64 ? "x64" : "x86");

        // udis requires python in its custom build step, so make sure it's on the
        // path
        //
        // BOOST_PATH is in the env because external_dependencies.props will
        // use it if it exists or reverts to a hardcoded path which might not be using
        // the same version as mob if it wasn't updated
        return std::move(
            msbuild(o)
                .platform(plat)
                .targets({"usvfs_proxy"})
                .solution(source_path() / "vsbuild" / "usvfs.sln")
                .env(env::vs(a)
                         .prepend_path(python::build_path())
                         .set("BOOST_PATH", path_to_utf8(boost::source_path()))));
    }

    std::vector<std::shared_ptr<downloader>>
    usvfs::create_appveyor_downloaders(arch a, downloader::ops o) const
    {
        std::string arch_s;

        switch (a) {
        case arch::x86:
            arch_s = "x86";
            break;

        case arch::x64:
            arch_s = "x64";
            break;

        case arch::dont_care:
        default:
            cx().bail_out(context::generic, "bad arch");
        }

        // returns an appveyor downloader for the given filename that outputs into
        // build/usvfs_bin[_32]/
        auto make_dl = [&](std::string filename) {
            const auto u          = make_appveyor_artifact_url(a, "usvfs", filename);
            const std::string dir = prebuilt_directory_name(a);

            auto dl = std::make_shared<downloader>(o);

            dl->url(u);
            dl->file(conf().path().build() / dir / u.filename());

            return dl;
        };

        std::vector<std::shared_ptr<downloader>> v;

        // five downloaders for the pdbs, dlls, libs and exes
        v.push_back(make_dl("lib/usvfs_" + arch_s + ".pdb"));
        v.push_back(make_dl("lib/usvfs_" + arch_s + ".dll"));
        v.push_back(make_dl("lib/usvfs_" + arch_s + ".lib"));
        v.push_back(make_dl("bin/usvfs_proxy_" + arch_s + ".exe"));
        v.push_back(make_dl("bin/usvfs_proxy_" + arch_s + ".pdb"));

        return v;
    }

    std::string usvfs::prebuilt_directory_name(arch a) const
    {
        switch (a) {
        case arch::x86:
            return "usvfs_bin_32";

        case arch::x64:
            return "usvfs_bin";

        case arch::dont_care:
        default:
            cx().bail_out(context::generic, "bad arch");
        }
    }

}  // namespace mob::tasks
